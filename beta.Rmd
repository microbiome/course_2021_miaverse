---
title: "Beta diversity"
output: html_document
---

This notebook calculates beta diversity.

Beta diversity reflects the difference in microbial composition between two samples. If two samples are similar to each other,
beta diversity is smaller. Several different distance metrics can be calculated (e.g. Bray Curtis, UniFrac, Jaccard etc.). Each metric emphasizes the differences between samples differently. After calculating a distance metric, we can vizualize the similarity/dissimilarity between samples by using dimension reduction techniques such as Principal Coordinate Analysis (PCoA).

PCoA uses a distance matrix as input. The output is usually a 2 or 3-dimensional 
euclidean space. The idea is to rotate data that way that the distances between 
different samples are maximized. 



## Examples of PCoA with different settings
### PCoA for ASV-level data with Bray-Curtis

```{r}
# Relative abundance table
rel_abund_assay <- assays(tse)$relabundance

# Transposes it to get taxa to columns
rel_abund_assay <- t(rel_abund_assay)

# Calculates Bray-Curtis distances between samples. Because taxa is in columns,
# it is used to compare different samples.
bray_curtis_dist <- vegan::vegdist(rel_abund_assay, method = "bray")

# Does principal coordinate analysis
bray_curtis_pcoa <- ecodist::pco(bray_curtis_dist)

# Creates a data frame from principal coordinates
bray_curtis_pcoa_df <- data.frame(pcoa1 = bray_curtis_pcoa$vectors[,1], 
                                  pcoa2 = bray_curtis_pcoa$vectors[,2])

# Creates a plot
bray_curtis_plot <- ggplot(data = bray_curtis_pcoa_df, aes(x=pcoa1, y=pcoa2)) +
  geom_point() +
  xlab("Coordinate 1") + # x axis title
  ylab("Coordinate 2") + # y axis title
  ggtitle("Bray-Curtis PCoA with relative abundances") + # main title
  theme(title = element_text(size = 12)) # makes titles smaller

bray_curtis_plot

```
### PCoA for ASV-level data with CLR transformation + Euclidean distance (Aitchison distance)

```{r}
# Does clr transformation. Pseudocount is added, because data contains zeros. 
tse <- transformCounts(tse, method = "clr", pseudocount = 1)

# Gets clr table
clr_assay <- assays(tse)$clr

# Transposes it to get taxa to columns
clr_assay <- t(clr_assay)

# Calculates Euclidean distances between samples. Because taxa is in columns,
# it is used to compare different samples.
euclidean_dist <- vegan::vegdist(clr_assay, method = "euclidean")


# Does principal coordinate analysis
euclidean_pcoa <- ecodist::pco(euclidean_dist)

# Creates a data frame from principal coordinates
euclidean_pcoa_df <- data.frame(pcoa1 = euclidean_pcoa$vectors[,1], 
                                pcoa2 = euclidean_pcoa$vectors[,2])

# Creates a plot
euclidean_plot <- ggplot(data = euclidean_pcoa_df, aes(x=pcoa1, y=pcoa2)) +
  geom_point() +
  xlab("Coordinate 1") + # x axis title
  ylab("Coordinate 2") + # y axis title
  ggtitle("Euclidean PCoA with CLR transformation") + # main title
  theme(title = element_text(size = 12)) # makes titles smaller

euclidean_plot

```

### PCoA aggregated to Phylum level with CLR transformation + Euclidean distance

```{r}
# Does clr transformation. Psuedocount is added, because data contains zeros. 
tse_phylum <- transformCounts(tse_phylum, method = "clr", pseudocount = 1)

# Gets clr table
clr_phylum_assay <- assays(tse_phylum)$clr

# Transposes it to get taxa to columns
clr_phylum_assay <- t(clr_phylum_assay)

# Calculates Euclidean distances between samples. Because taxa is in columns,
# it is used to compare different samples.
euclidean_phylum_dist <- vegan::vegdist(clr_assay, method = "euclidean")

# Does principal coordinate analysis
euclidean_phylum_pcoa <- ecodist::pco(euclidean_phylum_dist)

# Creates a data frame from principal coordinates
euclidean_phylum_pcoa_df <- data.frame(pcoa1 = euclidean_phylum_pcoa$vectors[,1], 
                                       pcoa2 = euclidean_phylum_pcoa$vectors[,2])

# Creates a plot
euclidean_phylum_plot <- ggplot(data = euclidean_phylum_pcoa_df, aes(x=pcoa1, y=pcoa2)) +
  geom_point() +
  xlab("Coordinate 1") + # x axis title
  ylab("Coordinate 2") + # y axis title
  ggtitle("Euclidean PCoA with Phylum level CLR transformation") + # main title
  theme(title = element_text(size = 12)) # makes titles smaller

euclidean_phylum_plot

```
## Examples on showing external variables on PCoA plot
### PCoA with discrete sample grouping variable shown with colors

We can add grouping variable to existing plots. Let's add coloring to the CLR transformed,
Genus level PCoA

```{r}
# Adds coloring information to the data frame, creates new column
euclidean_patient_status_pcoa_df <- cbind(euclidean_pcoa_df,
                             patient_status = colData(tse)$patient_status)

# Creates a plot
euclidean_patient_status_plot <- ggplot(data = euclidean_patient_status_pcoa_df, 
                                        aes(x=pcoa1, y=pcoa2,
                                            color = patient_status)) +
  geom_point() +
  xlab("Coordinate 1") + # x axis title
  ylab("Coordinate 2") + # y axis title
  ggtitle("Euclidean PCoA with CLR transformation") + # main title
  theme(title = element_text(size = 12)) # makes titles smaller

euclidean_patient_status_plot
```
### PCoA with continuous sample grouping variable shown with colors

We can also use continues values to group variables. Let's use Shannon diversity
index that we calculated in "Alpha diversity" notebook.

```{r}
# Adds coloring information to the data frame, creates new column
euclidean_shannon_pcoa_df <- cbind(euclidean_pcoa_df,
                             shannon = colData(tse)$Shannon_index)

# Creates a plot
euclidean_shannon_plot <- ggplot(data = euclidean_shannon_pcoa_df, 
                                 aes(x=pcoa1, y=pcoa2,
                                     color = shannon)) + 
  geom_point() +
  xlab("Coordinate 1") + # x axis title
  ylab("Coordinate 2") + # y axis title
  ggtitle("Euclidean PCoA with CLR transformation") + # main title
  theme(title = element_text(size = 12)) # makes titles smaller

euclidean_shannon_plot
```
## Example on clustering
### Dirichlet-Multinomial Mixture clustering 

Another technique that allows to search for groups of samples that are similar to each other is a [Dirichlet-Multinomial Mixture Model](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0030126). In DMM, we first determine the number of clusters (k) that best fit the data (model evidence) using Laplace approximation. After fitting the model with k clusters, we obtain for each sample k probabilities that reflect the probability that a sample belongs to the given cluster.

Let's cluster the data with DMM clusteting. 

```{r}
# Runs model and calculates the most likely number of clusters from 1 to 7. 
# For this small data, takes about 10 seconds. For larger data, can take much longer
# because this demands lots of resources. 
tse_dmn <- runDMN(tse, name = "DMN", k = 1:7)
```

```{r}
# It is stored in metadata
tse_dmn
```

```{r}
# Returns information what metadata the object contains
names(metadata(tse_dmn))
```

```{r}
# Returns a list of DMN objects
getDMN(tse_dmn)
```


```{r}
# Laplace approximation (model evidence) for each model of the k models
plot_dmn_fit <- plotDMNFit(tse_dmn, type = "laplace")
```

```{r}
# Returns the model, which fits best
getBestDMNFit(tse_dmn, type = "laplace")
```


### PCoA for ASV-level data with Bray-Curtis; with DMM clusters shown with colors

```{r}
# Does the grouping. Returns DMNGroup object that contains a summary. 
# Patient status is used for grouping. 
dmn_group <- calculateDMNgroup(tse_dmn, variable = "patient_status", 
                             exprs_values = "counts", k = 3)

dmn_group
```

```{r}
# Weights
DirichletMultinomial::mixturewt(getBestDMNFit(tse_dmn))
```

```{r}
# Samples' probabilities that tells the likelihood to belong to component
head(DirichletMultinomial::mixture(getBestDMNFit(tse_dmn)))
```

```{r}
# Contribution of samples to each component
head(DirichletMultinomial::fitted(getBestDMNFit(tse_dmn)))
```

```{r}
# Gets the probabilities
prob <- DirichletMultinomial::mixture(getBestDMNFit(tse_dmn))
# Add column names
colnames(prob) <- c("comp1", "comp2", "comp3")

# For each row, finds column that has the highest value. Then extract the column 
# names of highest values.
vec <- colnames(prob)[max.col(prob,ties.method = "first")]

# Creates a data frame that contains principal coordinates and DMM information
euclidean_dmm_pcoa_df <- cbind(euclidean_pcoa_df,
                               dmm_component = vec)

# Creates a plot
euclidean_dmm_plot <- ggplot(data = euclidean_dmm_pcoa_df, 
                             aes(x=pcoa1, y=pcoa2,
                                 color = dmm_component)) +
  geom_point() +
  xlab("Coordinate 1") + # x axis title
  ylab("Coordinate 2") + # y axis title
  ggtitle("Euclidean PCoA with CLR transformation") + # main title
  theme(title = element_text(size = 12)) # makes titles smaller

euclidean_dmm_plot
```

## Example of associations
Next we can perform a permutational multivariate analysis of variance (permanova) test. Here, we test if
different cohorts explain the variance of abundance between samples. 

```{r}
# Relative abundance table
rel_abund_assay <- assays(tse)$relabundance

# Transposes it to get taxa to columns
rel_abund_assay <- t(rel_abund_assay)

permanova_cohort <- vegan::adonis(rel_abund_assay ~ cohort,
                                  data = colData(tse),
                                  permutations = 9999)

# P-value
print(paste0("Different different cohorts and variance of abundance between samples, p-value: ", 
             as.data.frame(permanova_cohort$aov.tab)["cohort", "Pr(>F)"]))
```
As we can see, the cohorts variable is not significantly associated with microbiota composition as the p-value is over 0.05. 


We can visualize those taxa whose abundance are the most different between cohorts. 
This gives us information which taxa's abundances tend to differ between different 
cohorts. 

In order to do that, we need coefficients of taxa.

```{r}
# Gets the coefficients
coef <- coefficients(permanova_cohort)["cohort1",]
# Gets the highest coefficients
top.coef <- sort(head(coef[rev(order(abs(coef)))],20))

# Plots the coefficients
top_taxa_coeffient_plot <- ggplot(data.frame(x = top.coef,
                                             y = factor(names(top.coef),
                                                        unique(names(top.coef)))),
                                  aes(x = x, y = y)) +
  geom_bar(stat="identity") +
  labs(x="",y="",title="Top Taxa") +
  theme_bw()

top_taxa_coeffient_plot
```

This plot above showed taxa as code names. From the plot, it is hard to tell which taxa 
they represent. However, it is easy to add real names to plot. The lowest available 
taxonomic level is Genus, so let's first agglomerate taxa to Genus level.

```{r}
# Agglomerates data to Genus level
tse_genus <- agglomerateByRank(tse, rank = "Genus")
# Relative abundance table
rel_abund_assay_genus <- assays(tse_genus)$relabundance

# Transposes it to get taxa to columns
rel_abund_assay_genus <- t(rel_abund_assay_genus)

permanova_cohort_genus <- vegan::adonis(rel_abund_assay_genus ~ cohort,
                                        data = colData(tse_genus),
                                        permutations = 9999)

# P-value
print(paste0("Different different cohorts and variance of abundance between samples, p-value: ", 
             as.data.frame(permanova_cohort_genus$aov.tab)["cohort", "Pr(>F)"]))
```

```{r}
# Gets the coefficients
coef <- coefficients(permanova_cohort_genus)["cohort1",]
# Gets the highest coefficients
top.coef <- sort(head(coef[rev(order(abs(coef)))],20))

# Plots the coefficients
top_taxa_coeffient_genus_plot <- ggplot(data.frame(x = top.coef,
                                                   y = factor(names(top.coef),
                                                              unique(names(top.coef)))),
                                        aes(x = x, y = y)) +
  geom_bar(stat="identity") +
  labs(x="",y="",title="Top Taxa") +
  theme_bw()

top_taxa_coeffient_genus_plot
```
