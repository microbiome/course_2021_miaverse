---
title: "Beta diversity"
output: html_document
---

This notebook calculates beta diversity.

Beta diversity measures diversity between different samples. If there are many
different samples, beta diversity is larger. If samples are similar to each other,
beta diversity is smaller. 

We use Principal Coordinate Analysis (PCoA) and Dirichlet-Multinomial Mixture Clustering
(DMM) to find patterns from our data. 

PCoA uses distance matrix as input. The output is usually 2 or 3-dimensional 
euclidean space. The idea is to rotate data that way that the distances between 
different samples are maximized. 

DMM is used to cluster taxa into different groups by their variance. In DMM, probabilities
or frequencies are calculated. They represent how likely it is that each sample is present
in each cluster. 

## Examples of PCoA with different settings
### PCoA for ASV-level data with Bray-Curtis

```{r}
# Relative abundance table
rel_abund_assay <- assays(tse)$relabundance

# Transposes it to get taxa to columns
rel_abund_assay <- t(rel_abund_assay)

# Calculates Bray-Curtis distances between samples. Because taxa is in columns,
# it is used to compare different samples.
bray_curtis_dist <- vegan::vegdist(rel_abund_assay, method = "bray")

# Does principal coordinate analysis
bray_curtis_pcoa <- ecodist::pco(bray_curtis_dist)

# Creates a data frame from principal coordinates
bray_curtis_pcoa_df <- data.frame(pcoa1 = bray_curtis_pcoa$vectors[,1], 
                                  pcoa2 = bray_curtis_pcoa$vectors[,2])

# Creates a plot
bray_curtis_plot <- ggplot(data = bray_curtis_pcoa_df, aes(x=pcoa1, y=pcoa2)) +
  geom_point() +
  xlab("Coordinate 1") + # x axis title
  ylab("Coordinate 2") + # y axis title
  ggtitle("Bray-Curtis PCoA with relative abundances") + # main title
  theme(title = element_text(size = 12)) # makes titles smaller

bray_curtis_plot

```
### PCoA for ASV-level data with CLR transformation + Euclidean distance

```{r}
# Does clr transformation. Pseudocount is added, because data contains zeros. 
tse <- transformCounts(tse, method = "clr", pseudocount = 1)

# Gets clr table
clr_assay <- assays(tse)$clr

# Transposes it to get taxa to columns
clr_assay <- t(clr_assay)

# Calculates Euclidean distances between samples. Because taxa is in columns,
# it is used to compare different samples.
euclidean_dist <- vegan::vegdist(clr_assay, method = "euclidean")

# Does principal coordinate analysis
euclidean_pcoa <- ecodist::pco(euclidean_dist)

# Creates a data frame from principal coordinates
euclidean_pcoa_df <- data.frame(pcoa1 = euclidean_pcoa$vectors[,1], 
                                pcoa2 = euclidean_pcoa$vectors[,2])

# Creates a plot
euclidean_plot <- ggplot(data = euclidean_pcoa_df, aes(x=pcoa1, y=pcoa2)) +
  geom_point() +
  xlab("Coordinate 1") + # x axis title
  ylab("Coordinate 2") + # y axis title
  ggtitle("Euclidean PCoA with CLR transformation") + # main title
  theme(title = element_text(size = 12)) # makes titles smaller

euclidean_plot

```

### PCoA aggregated to Phylum level with CLR transformation + Euclidean distance

```{r}
# Does clr transformation. Psuedocount is added, because data contains zeros. 
tse_phylum <- transformCounts(tse_phylum, method = "clr", pseudocount = 1)

# Gets clr table
clr_phylum_assay <- assays(tse_phylum)$clr

# Transposes it to get taxa to columns
clr_phylum_assay <- t(clr_phylum_assay)

# Calculates Euclidean distances between samples. Because taxa is in columns,
# it is used to compare different samples.
euclidean_phylum_dist <- vegan::vegdist(clr_assay, method = "euclidean")

# Does principal coordinate analysis
euclidean_phylum_pcoa <- ecodist::pco(euclidean_phylum_dist)

# Creates a data frame from principal coordinates
euclidean_phylum_pcoa_df <- data.frame(pcoa1 = euclidean_phylum_pcoa$vectors[,1], 
                                       pcoa2 = euclidean_phylum_pcoa$vectors[,2])

# Creates a plot
euclidean_phylum_plot <- ggplot(data = euclidean_phylum_pcoa_df, aes(x=pcoa1, y=pcoa2)) +
  geom_point() +
  xlab("Coordinate 1") + # x axis title
  ylab("Coordinate 2") + # y axis title
  ggtitle("Euclidean PCoA with Phylum level CLR transformation") + # main title
  theme(title = element_text(size = 12)) # makes titles smaller

euclidean_phylum_plot

```
## Examples on showing external variables on PCoA plot
### PCoA with discrete sample grouping variable shown with colors

We can add grouping variable to existing plots. Let's add coloring to the CLR transformed,
Genus level PCoA

```{r}
# Adds coloring information to the data frame, creates new column
euclidean_patient_status_pcoa_df <- cbind(euclidean_pcoa_df,
                             patient_status = colData(tse)$patient_status)

# Creates a plot
euclidean_patient_status_plot <- ggplot(data = euclidean_patient_status_pcoa_df, 
                                        aes(x=pcoa1, y=pcoa2,
                                            color = patient_status)) +
  geom_point() +
  xlab("Coordinate 1") + # x axis title
  ylab("Coordinate 2") + # y axis title
  ggtitle("Euclidean PCoA with CLR transformation") + # main title
  theme(title = element_text(size = 12)) # makes titles smaller

euclidean_patient_status_plot
```
### PCoA with continuous sample grouping variable shown with colors

We can also use continues values to group variables. Let's use Shannon diversity
index that we calculated in "Alpha diversity" notebook.

```{r}
# Adds coloring information to the data frame, creates new column
euclidean_shannon_pcoa_df <- cbind(euclidean_pcoa_df,
                             shannon = colData(tse)$Shannon_index)

# Creates a plot
euclidean_shannon_plot <- ggplot(data = euclidean_shannon_pcoa_df, 
                                 aes(x=pcoa1, y=pcoa2,
                                     color = shannon)) + 
  geom_point() +
  xlab("Coordinate 1") + # x axis title
  ylab("Coordinate 2") + # y axis title
  ggtitle("Euclidean PCoA with CLR transformation") + # main title
  theme(title = element_text(size = 12)) # makes titles smaller

euclidean_shannon_plot
```
## Example on clustering
### Dirichlet-Multinomial Mixture clustering 

Next,  let's cluster the data with DMM clusteting. 

```{r}
# Runs model and calculates the most likely number of clusters from 1 to 7. 
# For this small data, takes about 10 seconds. For larger data, can take much longer
# because this demands lots of resources. 
tse_dmn <- runDMN(tse, name = "DMN", k = 1:7)
```

```{r}
# It is stored in metadata
tse_dmn
```

```{r}
# Returns information what metadata the object contains
names(metadata(tse_dmn))
```

```{r}
# Returns a list of DMN objects
getDMN(tse_dmn)
```

```{r}
# Returns the model, which fits best
getBestDMNFit(tse_dmn, type = "laplace")
```

```{r}
# Plots the DMN
plot_dmn_fit <- plotDMNFit(tse_dmn, type = "laplace")

plot_dmn_fit
```
### PCoA for ASV-level data with Bray-Curtis; with DMM clusters shown with colors

```{r}
# Does the grouping. Returns DMNGroup object that contains a summary. 
# Patient status is used for grouping. 
dmn_group <- calculateDMNgroup(tse_dmn, variable = "patient_status", 
                             exprs_values = "counts", k = 3)

dmn_group
```

```{r}
# Weights
DirichletMultinomial::mixturewt(getBestDMNFit(tse_dmn))
```

```{r}
# Samples' probabilities that tells the likelihood to belong to component
head(DirichletMultinomial::mixture(getBestDMNFit(tse_dmn)))
```

```{r}
# Contribution of samples to each component
head(DirichletMultinomial::fitted(getBestDMNFit(tse_dmn)))
```

```{r}
# Gets the probabilities
prob <- DirichletMultinomial::mixture(getBestDMNFit(tse_dmn))
# Add column names
colnames(prob) <- c("comp1", "comp2", "comp3")

# For each row, finds column that has the highest value. Then extract the column 
# names of highest values.
vec <- colnames(prob)[max.col(prob,ties.method = "first")]

# Creates a data frame that contains principal coordinates and DMM information
euclidean_dmm_pcoa_df <- cbind(euclidean_pcoa_df,
                               dmm_component = vec)

# Creates a plot
euclidean_dmm_plot <- ggplot(data = euclidean_dmm_pcoa_df, 
                             aes(x=pcoa1, y=pcoa2,
                                 color = dmm_component)) +
  geom_point() +
  xlab("Coordinate 1") + # x axis title
  ylab("Coordinate 2") + # y axis title
  ggtitle("Euclidean PCoA with CLR transformation") + # main title
  theme(title = element_text(size = 12)) # makes titles smaller

euclidean_dmm_plot
```

## Example of associations
Next we can do permutation analysis of variance (permanova) test. Here, we test if
different cohorts explain the variance of abundance between samples. 

```{r}
# Relative abundance table
rel_abund_assay <- assays(tse)$relabundance

# Transposes it to get taxa to columns
rel_abund_assay <- t(rel_abund_assay)

permanova_genotype <- vegan::adonis(rel_abund_assay ~ cohort,
                                    data = colData(tse),
                                    permutations = 9999)

# P-value
print(paste0("Different different cohorts and variance of abundance between samples, p-value: ", 
             as.data.frame(permanova_genotype$aov.tab)["cohort", "Pr(>F)"]))
```
As we can see, cohorts do not explain the variance, because p-value is over 0.05. 
The abundances are not significantly different between cohorts.

We can visualize those taxa whose abundance are the most different between cohorts. 
This gives us information which taxa's abundances tend to differ between different 
samples. 

In order to do that, we need coefficients of taxa.

```{r}
# Gets the coefficients
coef <- coefficients(permanova_genotype)["cohort1",]
# Gets the highest coefficients
top.coef <- sort(head(coef[rev(order(abs(coef)))],20))

# Plots the coefficients
top_taxa_coeffient_plot <- ggplot(data.frame(x = top.coef,
                                             y = factor(names(top.coef),
                                                        unique(names(top.coef)))),
                                  aes(x = x, y = y)) +
  geom_bar(stat="identity") +
  labs(x="",y="",title="Top Taxa") +
  theme_bw()

top_taxa_coeffient_plot
```

This plot above showed taxa as code names. From the plot, it is hard to tell which taxa 
they reppresent. However, it is easy to add real names to plot.

```{r}
# Let's fetch names from rowData, and assign those to names
names(top.coef) <- rowData(tse)[names(top.coef),]$Genus

# And do the same plotting
top_taxa_names_coeffient_plot <- ggplot(data.frame(x = top.coef,
                                             y = factor(names(top.coef),
                                                        unique(names(top.coef)))),
                                  aes(x = x, y = y)) +
  geom_bar(stat="identity") +
  labs(x="",y="",title="Top Taxa") +
  theme_bw()

top_taxa_names_coeffient_plot
```