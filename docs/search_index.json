[["index.html", "Miscellaneous material 1 Overview 1.1 The miaverse framework 1.2 Learning goals 1.3 Acknowledgments", " Miscellaneous material Leo Lahti, Tuomas Borman, Henrik Eckermann 2021-07-01 1 Overview Welcome to Radboud Summer School, July 2021 Figure source: Moreno-Indias et al. (2021) Statistical and Machine Learning Techniques in Human Microbiome Studies: Contemporary Challenges and Solutions. Frontiers in Microbiology 12:11. 1.1 The miaverse framework The miaverse (mia = MIcrobiome Analysis) is an R/Bioconductor framework for microbiome data science. It aims to extend the capabilities of another popular framework, phyloseq. The miaverse framework consists of an efficient data structure, an associated package ecosystem, demonstration data sets, and open documentation. These are explained in more detail in the online book Orchestrating Microbiome Analysis. This training material walks you through an example workflow that shows the standard steps of taxonomic data analysis covering data access, exploration, analysis, visualization and reporoducible reporting. You can run the workflow by simply copy-pasting the examples. For advanced material, you can test and modify further examples from the OMA book, or try to apply the techniques to your own data. 1.2 Learning goals This course provides an overview of the standard bioinformatics workflow in taxonomic profiling studies, ranging from data preprocessing to statistical analysis and reproducible reporting, with a focus on examples from human gut microbiota studies. You will become familiar with standard bioinformatics concepts and methods in taxonomic profiling studies of the human microbiome. This includes better understanding of the specific statistical challenges, practical hands-on experience with the commonly used methods, and reproducible research with R. After the course you will know how to approach new tasks in microbiome data science by utilizing available documentation and R tools. Target audience Advanced students and applied researchers who wish to develop their skills in microbial community analysis. Venue Radboud University / Online, Nijmegen. July 5-16, 2021, with contributions by University of Turku, Finland. 1.3 Acknowledgments Citation “Introduction to miaverse (2021). Tuomas Borman, Felix Ernst, Sudarshan Shetty, Henrik Eckermann, Leo Lahti. URL: https://microbiome.github.io.” Contact - Leo Lahti, University of Turku - mia Collective License All material is released under the open CC BY-NC-SA 3.0 License. Landing page (html): miaverse teaching material Source code (github): miaverse teaching material The source code of this repository is fully reproducible and contains the Rmd files with executable code. All files can be rendered at one go by running the file main.R. You can check the file for details on how to clone the repository and convert it into a gitbook, although this is not necessary for the training. "],["program.html", "2 Program 2.1 Monday 12 July: from raw sequences to ecological data analysis 2.2 Tuesday 13 July: Key concepts in data analysis: alpha diversity 2.3 Wednesday 14 July: Key concepts in data analysis: beta diversity 2.4 Thursday 15 July: Key concepts in data analysis: differential abundance 2.5 Friday 16 July: Presentations &amp; closing 2.6 Course assignments (TODO)", " 2 Program 2.1 Monday 12 July: from raw sequences to ecological data analysis Lecture: Microbiota analysis: association studies vs. causality; microbiota sequencing methods (16S, shotgun, metagenomics) by dr. Tom Ederveen (Radboudumc Nijmegen, The Netherlands) Lecture: DNA isolation and 16S rRNA gene sequencing; bioinformatics step 1: from raw sequences to OTU table in a biom file – by Tom Ederveen (Radboudumc Nijmegen, The Netherlands) Demonstration &amp; Practical: Importing the data to R environment for interactive data analysis – by prof. dr. Leo Lahti (University of Turku, Finland) -&gt; OK: import.Rmd + explanation of R, Bioconductor, TSE 2.2 Tuesday 13 July: Key concepts in data analysis: alpha diversity Lecture: Overview of key concepts in microbiota data science - by prof. dr. Leo Lahti (University of Turku, Finland) Demonstration: Community diversity – by prof. dr. Leo Lahti (University of Turku, Finland) Practical: Estimating, comparing, and visualizing alpha diversity 2.3 Wednesday 14 July: Key concepts in data analysis: beta diversity Demonstration: Community similarity - by prof. dr. Leo Lahti (University of Turku, Finland) Practical: estimating and visualizing beta diversity Practical: quantifying factors that drive community variation 2.4 Thursday 15 July: Key concepts in data analysis: differential abundance Demonstration: Differential abundance analysis methods - by prof. dr. Leo Lahti (University of Turku, Finland) Practical: Differential abundance analysis in practice Practical: Overview of microbiota data science methods &amp; concepts 2.5 Friday 16 July: Presentations &amp; closing Presentations on the data analysis by each group of students 2.6 Course assignments (TODO) 2.6.1 Monday 12 July: DONE Data import demo &amp; practical: [import.md] Data exploration: [explore.md] 2.6.2 Tue 13 July: alpha diversity Lecture on key concepts Demo on community diversity Richness: Observed, Chao1 Diversity: Shannon, Faith Visualize, compare Practical Estimation: Choose and compare three different alpha diversity indices Diversity: Shannon Diversity: Faith Visualizing Comparing "],["getting-started.html", "3 Getting started 3.1 Checklist (before the course) 3.2 Support and resources", " 3 Getting started 3.1 Checklist (before the course) Install the following software in advance in order to avoid unnecessary delays and leaving more time for the course contents. R (version &gt;4.1.0) RStudio; choose “Rstudio Desktop” to download the latest version. Optional but preferred. For further details, check the Rstudio home page. Install and load required R packages. After a successful installation you can start trying out the case study examples in this training material 3.2 Support and resources For additional reading and online material, see Material section For online support on installation and other matters, you can join us at: Users: miaverse Gitter channel Developers: Bioconductor Slack #microbiomeexperiment channel "],["install-and-load-required-r-packages.html", "4 Install and load required R packages", " 4 Install and load required R packages In this section, all required packages are installed and loaded into the session. If packages are already installed, installation step is skipped; only uninstalled packages are installed. # List of packages that we need from cran and bioc cran_pkg &lt;- c(&quot;BiocManager&quot;, &quot;bookdown&quot;, &quot;dplyr&quot;, &quot;ecodist&quot;, &quot;ggplot2&quot;, &quot;gridExtra&quot;, &quot;knitr&quot;, &quot;vegan&quot;) bioc_pkg &lt;- c(&quot;ANCOMBC&quot;, &quot;ape&quot;, &quot;DESeq2&quot;, &quot;DirichletMultinomial&quot;, &quot;mia&quot;, &quot;miaViz&quot;) # Gets those packages that are already installed cran_pkg_already_installed &lt;- cran_pkg[ cran_pkg %in% installed.packages() ] bioc_pkg_already_installed &lt;- bioc_pkg[ bioc_pkg %in% installed.packages() ] # Gets those packages that need to be installed cran_pkg_to_be_installed &lt;- setdiff(cran_pkg, cran_pkg_already_installed) bioc_pkg_to_be_installed &lt;- setdiff(bioc_pkg, bioc_pkg_already_installed) # If there are packages that need to be installed, installs them from CRAN if( length(cran_pkg_to_be_installed) ) { install.packages(cran_pkg_to_be_installed) } # If there are packages that need to be installed, installs them from Bioconductor if( length(bioc_pkg_to_be_installed) ) { BiocManager::install(bioc_pkg_to_be_installed, ask = F) } Now all required packages are installed, so let’s load them into the session. Some function names occur in multiple packages. That is why miaverse’s packages mia and miaViz are prioritized. Packages that are loaded first have higher priority. # Reorders bioc packages, so that mia and miaViz are first bioc_pkg &lt;- c(bioc_pkg[ bioc_pkg %in% c(&quot;mia&quot;, &quot;miaViz&quot;) ], bioc_pkg[ !bioc_pkg %in% c(&quot;mia&quot;, &quot;miaViz&quot;) ] ) # Loading all packages into session. Returns true if package was successfully loaded. sapply(c(bioc_pkg, cran_pkg), require, character.only = TRUE) ## mia miaViz ANCOMBC ape DESeq2 DirichletMultinomial ## TRUE TRUE TRUE TRUE TRUE TRUE ## BiocManager bookdown dplyr ecodist ggplot2 gridExtra ## TRUE TRUE TRUE TRUE TRUE TRUE ## knitr vegan ## TRUE TRUE "],["import-data.html", "5 Import data 5.1 Data 5.2 Investigate the R data object", " 5 Import data This section shows how to import the biom and its accompanying data files to a TreeSummarizedExperiment object. A TSE object is a standard data structure that is utilized in the miaverse. We use example data from the following publication: Tengeler AC, Dam SA, Wiesmann M, Naaijen J, van Bodegom M, Belzer C, Dederen PJ, Verweij V, Franke B, Kozicz T, Vasquez AA &amp; Kiliaan AJ (2020) Gut microbiota from persons with attention-deficit/hyperactivity disorder affects the brain in mice. Microbiome 8:44. In this study, mice are colonized with microbiota from participants with ADHD (attention deficit hyperactivity disorder) and healthy participants. The aim of the study was to assess whether the mice display ADHD behaviors after being inoculated with ADHD microbiota, suggesting a role of the microbiome in ADHD pathology. 5.1 Data The Data is located in a “data” subfolder. It consists of 3 files: biom file: contains an abundance table and taxonomy information csv file: contains the sample metadata tree file: contains a phylogenetic tree. Define source file paths. biom_file_path &lt;- &quot;data/Aggregated_humanization2.biom&quot; sample_meta_file_path &lt;- &quot;data/Mapping_file_ADHD_aggregated.csv&quot; tree_file_path &lt;- &quot;data/Data_humanization_phylo_aggregation.tre&quot; Load the (biom) data into a SummarizedExperiment (SE) object. se &lt;- loadFromBiom(biom_file_path) 5.2 Investigate the R data object We have now imported the data set in R. Let us investigate its contents. print(se) ## class: SummarizedExperiment ## dim: 151 27 ## metadata(0): ## assays(1): counts ## rownames(151): 1726470 1726471 ... 17264756 17264757 ## rowData names(6): taxonomy1 taxonomy2 ... taxonomy5 taxonomy6 ## colnames(27): A110 A111 ... A38 A39 ## colData names(0): The assays slot includes a list of abundance tables. The imported abundance table is named as “counts.” Let us inspect only the first cols and rows. assays(se)$counts[1:3, 1:3] ## A110 A111 A12 ## 1726470 17722 11630 0 ## 1726471 12052 0 2679 ## 17264731 0 970 0 5.2.1 rowData (taxonomic information) The rowdata includes taxonomic information from the biom file. The head() command shows just the beginning of the data table for an overview. knitr::kable() is for printing the information more nicely. knitr::kable(head(rowData(se))) taxonomy1 taxonomy2 taxonomy3 taxonomy4 taxonomy5 taxonomy6 1726470 \"k__Bacteria p__Bacteroidetes c__Bacteroidia o__Bacteroidales f__Bacteroidaceae g__Bacteroides\" 1726471 \"k__Bacteria p__Bacteroidetes c__Bacteroidia o__Bacteroidales f__Bacteroidaceae g__Bacteroides\" 17264731 \"k__Bacteria p__Bacteroidetes c__Bacteroidia o__Bacteroidales f__Porphyromonadaceae g__Parabacteroides\" 17264726 \"k__Bacteria p__Bacteroidetes c__Bacteroidia o__Bacteroidales f__Bacteroidaceae g__Bacteroides\" 1726472 \"k__Bacteria p__Verrucomicrobia c__Verrucomicrobiae o__Verrucomicrobiales f__Verrucomicrobiaceae g__Akkermansia\" 17264724 \"k__Bacteria p__Bacteroidetes c__Bacteroidia o__Bacteroidales f__Bacteroidaceae g__Bacteroides\" These taxonomic rank names (column names) are not real rank names. Let’s replace them with real rank names. In addition to that, the taxa names include, e.g., ’\"k__’ before the name, so let’s make them cleaner by removing them. names(rowData(se)) &lt;- c(&quot;Kingdom&quot;, &quot;Phylum&quot;, &quot;Class&quot;, &quot;Order&quot;, &quot;Family&quot;, &quot;Genus&quot;) # Goes through the whole DataFrame. Removes &#39;.*[kpcofg]__&#39; from strings, where [kpcofg] # is any character from listed ones, and .* any character. rowdata_modified &lt;- BiocParallel::bplapply(rowData(se), FUN = stringr::str_remove, pattern = &#39;.*[kpcofg]__&#39;) # Genus level has additional &#39;\\&quot;&#39;, so let&#39;s delete that also rowdata_modified &lt;- BiocParallel::bplapply(rowdata_modified, FUN = stringr::str_remove, pattern = &#39;\\&quot;&#39;) # rowdata_modified is a list, so it is converted back to DataFrame format. rowdata_modified &lt;- DataFrame(rowdata_modified) # And then assigned back to the SE object rowData(se) &lt;- rowdata_modified # Now we have a nicer table knitr::kable(head(rowData(se))) Kingdom Phylum Class Order Family Genus 1726470 Bacteria Bacteroidetes Bacteroidia Bacteroidales Bacteroidaceae Bacteroides 1726471 Bacteria Bacteroidetes Bacteroidia Bacteroidales Bacteroidaceae Bacteroides 17264731 Bacteria Bacteroidetes Bacteroidia Bacteroidales Porphyromonadaceae Parabacteroides 17264726 Bacteria Bacteroidetes Bacteroidia Bacteroidales Bacteroidaceae Bacteroides 1726472 Bacteria Verrucomicrobia Verrucomicrobiae Verrucomicrobiales Verrucomicrobiaceae Akkermansia 17264724 Bacteria Bacteroidetes Bacteroidia Bacteroidales Bacteroidaceae Bacteroides 5.2.2 colData (sample information) We notice that the imported biom file did not contain the sample meta data yet, so it includes an empty data frame. head(colData(se)) ## DataFrame with 6 rows and 0 columns Let us add a sample meta data file. # We use this to check what type of data it is # read.table(sample_meta_file_path) # It seems like a comma separated file and it does not include headers # Let us read it and then convert from data.frame to DataFrame # (required for our purposes) sample_meta &lt;- DataFrame(read.table(sample_meta_file_path, sep = &quot;,&quot;, header = FALSE)) # Add sample names to rownames rownames(sample_meta) &lt;- sample_meta[,1] # Delete column that included sample names sample_meta[,1] &lt;- NULL # We can add headers colnames(sample_meta) &lt;- c(&quot;patient_status&quot;, &quot;cohort&quot;, &quot;patient_status_vs_cohort&quot;, &quot;sample_name&quot;) # Then it can be added to colData colData(se) &lt;- sample_meta Now colData includes the sample metadata. Use kable to print it more nicely. knitr::kable(head(colData(se))) patient_status cohort patient_status_vs_cohort sample_name A110 ADHD Cohort_1 ADHD_Cohort_1 A110 A12 ADHD Cohort_1 ADHD_Cohort_1 A12 A15 ADHD Cohort_1 ADHD_Cohort_1 A15 A19 ADHD Cohort_1 ADHD_Cohort_1 A19 A21 ADHD Cohort_2 ADHD_Cohort_2 A21 A23 ADHD Cohort_2 ADHD_Cohort_2 A23 5.2.3 Phylogenetic tree information Now, let’s add a phylogenetic tree. The current data object, se, is a SummarizedExperiment object. This does not include a slot for adding a phylogenetic tree. In order to do this, we can convert the SE object to an extended TreeSummarizedExperiment object which also includes a rowTree slot. tse &lt;- as(se, &quot;TreeSummarizedExperiment&quot;) # tse includes same data as se print(tse) ## class: TreeSummarizedExperiment ## dim: 151 27 ## metadata(0): ## assays(1): counts ## rownames(151): 1726470 1726471 ... 17264756 17264757 ## rowData names(6): Kingdom Phylum ... Family Genus ## colnames(27): A110 A12 ... A35 A38 ## colData names(4): patient_status cohort patient_status_vs_cohort sample_name ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: NULL ## rowTree: NULL ## colLinks: NULL ## colTree: NULL Next, let us read the tree data file and add it to the R data object (tse). tree &lt;- ape::read.tree(tree_file_path) # Add tree to rowTree rowTree(tse) &lt;- tree # Check tse ## class: TreeSummarizedExperiment ## dim: 151 27 ## metadata(0): ## assays(1): counts ## rownames(151): 1726470 1726471 ... 17264756 17264757 ## rowData names(6): Kingdom Phylum ... Family Genus ## colnames(27): A110 A12 ... A35 A38 ## colData names(4): patient_status cohort patient_status_vs_cohort sample_name ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: a LinkDataFrame (151 rows) ## rowTree: 1 phylo tree(s) (151 leaves) ## colLinks: NULL ## colTree: NULL Now rowTree includes a phylogenetic tree: head(rowTree(tse)) "],["data-exploration.html", "6 Data exploration 6.1 Investigate the contents of a microbiome data object 6.2 Manipulate the data 6.3 Visualization 6.4 Further resources", " 6 Data exploration Now we have loaded the data set into R, and investigated that it has all the necessary components. Here, basic operations to briefly explore the data are introduced. 6.1 Investigate the contents of a microbiome data object Dimensionality tells us, how many taxa and samples the data contains. As we can see, there are 151 taxa and 27 samples. dim(tse) ## [1] 151 27 The rowData slot contains a taxonomic table. It includes taxonomic information for each 151 entries. With the head() command, it is possible to print only the beginning of the table. The rowData seems to contain information from 6 different taxonomy classes. knitr::kable(head(rowData(tse))) Kingdom Phylum Class Order Family Genus 1726470 Bacteria Bacteroidetes Bacteroidia Bacteroidales Bacteroidaceae Bacteroides 1726471 Bacteria Bacteroidetes Bacteroidia Bacteroidales Bacteroidaceae Bacteroides 17264731 Bacteria Bacteroidetes Bacteroidia Bacteroidales Porphyromonadaceae Parabacteroides 17264726 Bacteria Bacteroidetes Bacteroidia Bacteroidales Bacteroidaceae Bacteroides 1726472 Bacteria Verrucomicrobia Verrucomicrobiae Verrucomicrobiales Verrucomicrobiaceae Akkermansia 17264724 Bacteria Bacteroidetes Bacteroidia Bacteroidales Bacteroidaceae Bacteroides The colData slot contains sample metadata. It contains information for all 27 samples. However, here only the 6 first samples are shown as we use the head() command. There are 4 columns, that contain information, e.g., about patients’ status, and cohort. knitr::kable(head(colData(tse))) patient_status cohort patient_status_vs_cohort sample_name A110 ADHD Cohort_1 ADHD_Cohort_1 A110 A12 ADHD Cohort_1 ADHD_Cohort_1 A12 A15 ADHD Cohort_1 ADHD_Cohort_1 A15 A19 ADHD Cohort_1 ADHD_Cohort_1 A19 A21 ADHD Cohort_2 ADHD_Cohort_2 A21 A23 ADHD Cohort_2 ADHD_Cohort_2 A23 From here, we can observe, e.g., what is the patient status distribution. colData(tse)$patient_status fetches the data from the column, table() creates a table that shows how many times each class is present, and sort() sorts the table to ascending order. There are 13 samples from patients having ADHD, and 14 control samples. sort(table(colData(tse)$patient_status)) ## ## ADHD Control ## 13 14 6.2 Manipulate the data 6.2.1 Transformations Abundances are always relative even though absolute counts are calculated. That is due to technical aspects of the data generation process (see e.g. Gloor et al., 2017). Below, we calculate relative abundances as these are usually easier to interpret than plain counts. For some statistical models we need to transform the data into other formats as explained in above link (and as we will see later). # Calculates relative abundances, and stores the table to assays tse &lt;- transformCounts(tse, method = &quot;relabundance&quot;) 6.2.2 Aggregation We might want to know, which taxonomic rank is, e.g., the most abundant. We can easily agglomerate the data based on taxonomic ranks. Here, we agglomerate the data at Phylum level. tse_phylum &lt;- agglomerateByRank(tse, rank = &quot;Phylum&quot;) # Show dimensionality dim(tse_phylum) ## [1] 5 27 Now there are 5 taxa and 27 samples. It means that there are 5 different Phylum level taxa. From rowData we might see little bit easier, how ranks are agglomerated. For example, all Firmicutes are combined together. That is why all lower rank information is lost. From assay we could see, that all abundances of taxa that belongs to Firmicutes are summed up. knitr::kable(head(rowData(tse_phylum))) Kingdom Phylum Class Order Family Genus Bacteroidetes Bacteria Bacteroidetes NA NA NA NA Verrucomicrobia Bacteria Verrucomicrobia NA NA NA NA Proteobacteria Bacteria Proteobacteria NA NA NA NA Firmicutes Bacteria Firmicutes NA NA NA NA Cyanobacteria Bacteria Cyanobacteria NA NA NA NA Argument na.rm = FALSE in default. When na.rm = TRUE, taxa that do not have information in specified level is removed. When na.rm = FALSE, they are not removed. Then those taxa that do not have information in specified level are agglomerated at lowest possible level that is left after agglomeration. temp &lt;- rowData(agglomerateByRank(tse, rank = &quot;Genus&quot;)) # Prints those taxa that do not have information in Genus level knitr::kable(head(temp[temp$Genus == &quot;&quot;,])) Kingdom Phylum Class Order Family Genus Family:Lachnospiraceae Bacteria Firmicutes Clostridia Clostridiales Lachnospiraceae Order:Bacteroidales Bacteria Bacteroidetes Bacteroidia Bacteroidales Order:Clostridiales Bacteria Firmicutes Clostridia Clostridiales Family:Enterobacteriaceae Bacteria Proteobacteria Gammaproteobacteria Enterobacteriales Enterobacteriaceae Order:Gastranaerophilales Bacteria Cyanobacteria Melainabacteria Gastranaerophilales Here agglomeration is done similarly, but na.rm = TRUE temp2 &lt;- rowData(agglomerateByRank(tse, rank = &quot;Genus&quot;, na.rm = TRUE)) print(paste0(&quot;Agglomeration with na.rm = FALSE: &quot;, dim(temp)[1], &quot; taxa.&quot;)) ## [1] &quot;Agglomeration with na.rm = FALSE: 54 taxa.&quot; print(paste0(&quot;Agglomeration with na.rm = TRUE: &quot;, dim(temp2)[1], &quot; taxa.&quot;)) ## [1] &quot;Agglomeration with na.rm = TRUE: 49 taxa.&quot; 6.3 Visualization For plotting, we use miaViz package. We can plot the Phylum level abundances. # Here we specify &quot;relabundance&quot; to be abundance table that we use for plotting. # Note that we can use agglomerated or non-agglomerated tse as an input, because # the function agglomeration is built-in option. # Legend does not fit into picture, so its height is reduced. plot_abundance &lt;- plotAbundance(tse, abund_values=&quot;relabundance&quot;, rank = &quot;Phylum&quot;) + theme(legend.key.height = unit(0.5, &quot;cm&quot;)) + scale_y_continuous(label = scales::percent) ## Scale for &#39;y&#39; is already present. Adding another scale for &#39;y&#39;, which will replace the existing scale. plot_abundance From density plot, we could see, e.g., what is the most common abundance. Here we plot distribution of Firmicutes relative abundances in different samples. Density plot can be seen as smoothened histogram. From the plot, we can see that there are peak when abundance is little bit under 30 %. # Subset data by taking only Firmicutes tse_firmicutes &lt;- tse_phylum[&quot;Firmicutes&quot;] # Gets the abundance table abundance_firmicutes &lt;- assay(tse_firmicutes, &quot;relabundance&quot;) # Creates a data frame object, where first column includes abundances firmicutes_abund_df &lt;- as.data.frame(t(abundance_firmicutes)) # Rename the first and only column colnames(firmicutes_abund_df) &lt;- &quot;abund&quot; # Creates a plot. Parameters inside feom_density are optional. With # geom_density(bw=1000), it is possible to adjust bandwidth. firmicutes_abund_plot &lt;- ggplot(firmicutes_abund_df, aes(x = abund)) + geom_density(color=&quot;darkred&quot;, fill=&quot;lightblue&quot;) + labs(x = &quot;Relative abundance&quot;, title = &quot;Firmicutes&quot;) + theme_classic() + # Changes the background scale_x_continuous(label = scales::percent) firmicutes_abund_plot # # Does the same thing but differently # # Calculates the density. Bandwidth can be adjusted; here, it is 0.065. # # density() is from stats package # density_firmicutes &lt;- density(abundance_firmicutes, bw = 0.065) # # # Plots the density # plot(density_firmicutes, # xlab=&quot;Relative abundance&quot;, # ylab=&quot;Density&quot;, # main=paste0(&quot;Firmicutes (&quot;,density_firmicutes$n, &quot; obs, &quot;, density_firmicutes$bw, &quot; bw)&quot;)) 6.4 Further resources For more visualization options and examples, see the miaViz vignette. "],["alpha-diversity.html", "7 Alpha diversity 7.1 Visualization 7.2 Statistical testing and comparisons 7.3 Further resources", " 7 Alpha diversity This section demonstrates how alpha diversity indices are calculated. Alpha diversity is a quantity that measures diversity of taxa in within the sample. Higher numbers of unique taxa, and more even abundance distributions within a sample yield larger values for alpha diversity. Alpha diversity is an important quantity in a microbiome research. The mia package provides access to a wide variety of alpha diversity indices. As an example, we show how to calculate Shannon and Faith diversity indices. Shannon index reflects how many different taxa there are and how evenly they are distributed within a sample. Faith index additionally takes into account the phylogenetic relations between the taxa when quantifying the overall community diversity. In both indices, higher values represent higher diversity. # Indices to be calculated. If we don&#39;t specify indices, by default, every index # is calculated. indices &lt;- c(&quot;shannon&quot;, &quot;faith&quot;) # Indices are stored in colData (i.e., sample metadata). We can specify the name # of column, or we can use the default name which is the name of index # (i.e., &quot;shannon&quot; and &quot;faith&quot;). names &lt;- c(&quot;Shannon_index&quot;, &quot;Faith_diversity_index&quot;) # Calculates indices tse &lt;- estimateDiversity(tse, index = indices, name = names) # Shows the calculated indices knitr::kable(head(colData(tse)[names])) Shannon_index Faith_diversity_index A110 1.765407 7.39224 A12 2.716438 6.29378 A15 3.178103 6.60608 A19 2.891987 6.79708 A21 2.841979 6.65110 A23 2.797942 5.96246 Next we can visualize Shannon index with histogram. # ggplot needs data.frame as input. Because colData is DataFrame, it needs to be # converted. shannon_hist &lt;- ggplot(as.data.frame(colData(tse)), aes(x = Shannon_index)) + geom_histogram(bins = 20, fill = &quot;gray&quot;, color = &quot;black&quot;) + labs(x = &quot;Shannon index&quot;, y = &quot;Sample frequency&quot;) shannon_hist # # Same thing but done differently # # Creates histogram. With &quot;break&quot;, number of bins can be specified. However, the # # value is taken as a suggestion, because hist() uses pretty() to calculate breakpoints. # hist(colData(tse)$Shannon_index, col = &quot;green&quot;, breaks = 20, # xlab = &quot;Shannon index&quot;, # ylab = &quot;Sample frequency&quot;, # main = &quot;Histogram of Shannon index&quot;) To see, if there is dependency between Shannon and Faith, we can do cross-plot i.e., scatter plot, where one index is on the x-axis and another on the y-axis. It seems that, there is a positive correlation between these two indices. # # Does the same thing but differently # plot(colData(tse)$Shannon_index, colData(tse)$Faith_diversity_index, # xlab = &quot;Shannon index&quot;, # ylab = &quot;Faith diversity index&quot;, # main = &quot;plot()&quot;) + # # Adds regression line # abline(lm(colData(tse)$Faith_diversity_index ~ colData(tse)$Shannon_index)) cross_plot &lt;- ggplot2::ggplot(as.data.frame(colData(tse)), aes(x = Shannon_index, y = Faith_diversity_index)) + geom_point() + # Adds points geom_smooth(method=lm) + # Adds regression line xlab(&quot;Shannon index&quot;) + # x axis title ylab(&quot;Faith diversity index&quot;) # y axis title cross_plot ## `geom_smooth()` using formula &#39;y ~ x&#39; 7.1 Visualization Next let’s compare indices between different patient status and cohorts. Boxplot is suitable for that purpose. # Creates Shannon boxplot shannon_box &lt;- ggplot(as.data.frame(colData(tse)), aes(x = patient_status, y = Shannon_index, fill = cohort)) + geom_boxplot() + theme(title = element_text(size = 12)) # makes titles smaller # Creates Faith boxplot faith_box &lt;- ggplot(as.data.frame(colData(tse)), aes(x = patient_status, y = Faith_diversity_index, fill = cohort)) + geom_boxplot() + theme(title = element_text(size = 12)) # makes titles smaller # Puts them into same picture gridExtra::grid.arrange(shannon_box, faith_box, nrow = 2) 7.2 Statistical testing and comparisons To further investigate if patient status explains the variation of Shannon index, let’s do a Wilcoxon test. The Wilcoxon test is similar to a Student’s t-test, however, the Student’s t-test is parametric. It means that the data must be normally distributed. The Wilcoxon test is non-parametric so it doesn’t make any assumptions about the distribution. The Wilcoxon test tests if there are statistical differences between two groups. Here it tests, if ADHD and control groups have different Shannon index values. As we can see, there is no difference between groups, because the p-value is over 0.05, which is often used as a standard cutoff point. # Wilcoxon test, where Shannon index is the variable that we are comparing. # Patient status - ADHD or control - is the factor that we use for grouping. wilcoxon_shannon &lt;- wilcox.test(Shannon_index ~ patient_status, data = colData(tse)) wilcoxon_shannon ## ## Wilcoxon rank sum exact test ## ## data: Shannon_index by patient_status ## W = 76, p-value = 0.4879 ## alternative hypothesis: true location shift is not equal to 0 Another test that we can make is to test if ADHD samples differs between different cohorts. From boxplot that we made in previous step, we can see that there might be statistically significant difference between different cohorts. Let’s compare Shannon index of ADHD samples between cohort 2 and cohort 3. As we can see, there is statistically significant difference between the cohorts. # Takes subset of colData. Takes only ADHD samples ADHD_shannon &lt;- colData(tse)[ colData(tse)[, &quot;patient_status&quot;] == &quot;ADHD&quot; , ] # Takes subset of colData. Takes only samples that are in cohort 2 or cohort 3. ADHD_shannon &lt;- ADHD_shannon[ ADHD_shannon[, &quot;cohort&quot;] %in% c(&quot;Cohort_2&quot;, &quot;Cohort_3&quot;) , ] # Wilcoxon test, where Shannon index is the variable that we are comparing. # Cohort - 2 or 3 - is the factor that we use for grouping. wilcoxon_shannon_ADHD_cohorts &lt;- wilcox.test(Shannon_index ~ cohort, data = ADHD_shannon) wilcoxon_shannon_ADHD_cohorts ## ## Wilcoxon rank sum exact test ## ## data: Shannon_index by cohort ## W = 20, p-value = 0.01587 ## alternative hypothesis: true location shift is not equal to 0 7.3 Further resources For more examples, see a dedicated section on alpha diversity in the online book. "],["beta-diversity.html", "8 Beta diversity 8.1 Examples of PCoA with different settings 8.2 Highlighting external variables on PCoA plot 8.3 Estimating associations with an external variable 8.4 Further resources", " 8 Beta diversity In this section, we go through how to analyse and visualize beta diversity. Beta diversity reflects the difference in microbial composition between two samples. Similar samples have a low beta diversity. Several different distance metrics are available. Some of the common choices include Bray-Curtis, Unifrac, Jaccard, and Aitchison index. Each of these dissimilarity measures emphasize different aspects of similarity. 8.1 Examples of PCoA with different settings After estimating beta diversity we can visualize sample similarity with dimension reduction techniques such as Principal Coordinate Analysis (PCoA). PCoA takes a dissimilarity matrix as input. The output is usually a 2 or 3-dimensional euclidean space. The idea is to project the data so that the distances between different samples are maximized. The projection is often non-linear and designed to reveal local or global structures in the data distribution. NOTE: PCoA is not same as PCA (principal component analysis). In PCoA distance matrix is first calculated, but PCA takes the data as it is. The main idea of PCA is to find from multidimensional data those variables / components that cause most of the variance. After that data can be reduced, e.g., to 2-dimensional where x-axis represents variable 1 and y-axis variable 2. 8.1.1 PCoA for ASV-level data with Bray-Curtis Let us next show how to visualize sample similarities using the PCoA method and a selected dissimilarity measure. We use the same tse data object defined in the earlier notebooks. # Relative abundance table rel_abund_assay &lt;- assays(tse)$relabundance # Transposes it to get taxa to columns rel_abund_assay &lt;- t(rel_abund_assay) # Calculates Bray-Curtis distances between samples. Because taxa is in columns, # it is used to compare different samples. bray_curtis_dist &lt;- vegan::vegdist(rel_abund_assay, method = &quot;bray&quot;) # Does principal coordinate analysis bray_curtis_pcoa &lt;- ecodist::pco(bray_curtis_dist) # Creates a data frame from principal coordinates bray_curtis_pcoa_df &lt;- data.frame(pcoa1 = bray_curtis_pcoa$vectors[,1], pcoa2 = bray_curtis_pcoa$vectors[,2]) # Creates a plot bray_curtis_plot &lt;- ggplot(data = bray_curtis_pcoa_df, aes(x=pcoa1, y=pcoa2)) + geom_point() + labs(x = &quot;Coordinate 1&quot;, y = &quot;Coordinate 2&quot;, title = &quot;Bray-Curtis PCoA with relative abundances&quot;) + theme(title = element_text(size = 10)) # makes titles smaller bray_curtis_plot 8.1.2 PCoA for ASV-level data with Aitchison distance Aitchison distance corresponds to Euclidean distances between CLR transformed sample abundance vectors. # Does clr transformation. Pseudocount is added, because data contains zeros. tse &lt;- transformCounts(tse, method = &quot;clr&quot;, pseudocount = 1) # Gets clr table clr_assay &lt;- assays(tse)$clr # Transposes it to get taxa to columns clr_assay &lt;- t(clr_assay) # Calculates Euclidean distances between samples. Because taxa is in columns, # it is used to compare different samples. euclidean_dist &lt;- vegan::vegdist(clr_assay, method = &quot;euclidean&quot;) # Does principal coordinate analysis euclidean_pcoa &lt;- ecodist::pco(euclidean_dist) # Creates a data frame from principal coordinates euclidean_pcoa_df &lt;- data.frame(pcoa1 = euclidean_pcoa$vectors[,1], pcoa2 = euclidean_pcoa$vectors[,2]) # Creates a plot euclidean_plot &lt;- ggplot(data = euclidean_pcoa_df, aes(x=pcoa1, y=pcoa2)) + geom_point() + labs(x = &quot;Coordinate 1&quot;, y = &quot;Coordinate 2&quot;, title = &quot;Euclidean PCoA with CLR transformation&quot;) + theme(title = element_text(size = 12)) # makes titles smaller euclidean_plot 8.1.3 PCoA aggregated to Phylum level We use again the Aitchison distances in this example but this time we use data that was aggregated to the phylum level in the earlier examples. # Does clr transformation. Psuedocount is added, because data contains zeros. tse_phylum &lt;- transformCounts(tse_phylum, method = &quot;clr&quot;, pseudocount = 1) # Gets clr table clr_phylum_assay &lt;- assays(tse_phylum)$clr # Transposes it to get taxa to columns clr_phylum_assay &lt;- t(clr_phylum_assay) # Calculates Euclidean distances between samples. Because taxa is in columns, # it is used to compare different samples. euclidean_phylum_dist &lt;- vegan::vegdist(clr_assay, method = &quot;euclidean&quot;) # Does principal coordinate analysis euclidean_phylum_pcoa &lt;- ecodist::pco(euclidean_phylum_dist) # Creates a data frame from principal coordinates euclidean_phylum_pcoa_df &lt;- data.frame(pcoa1 = euclidean_phylum_pcoa$vectors[,1], pcoa2 = euclidean_phylum_pcoa$vectors[,2]) # Creates a plot euclidean_phylum_plot &lt;- ggplot(data = euclidean_phylum_pcoa_df, aes(x=pcoa1, y=pcoa2)) + geom_point() + labs(x = &quot;Coordinate 1&quot;, y = &quot;Coordinate 2&quot;, title = &quot;Aitchison distances at Phylum level&quot;) + theme(title = element_text(size = 12)) # makes titles smaller euclidean_phylum_plot 8.2 Highlighting external variables on PCoA plot 8.2.1 PCoA with discrete sample grouping variable shown with colors We can add grouping variable to existing plots. Let’s add coloring to the CLR transformed, Genus level PCoA. # Adds coloring information to the data frame, creates new column euclidean_patient_status_pcoa_df &lt;- cbind(euclidean_pcoa_df, patient_status = colData(tse)$patient_status) # Creates a plot euclidean_patient_status_plot &lt;- ggplot(data = euclidean_patient_status_pcoa_df, aes(x=pcoa1, y=pcoa2, color = patient_status)) + geom_point() + labs(x = &quot;Coordinate 1&quot;, y = &quot;Coordinate 2&quot;, title = &quot;PCoA with Aitchison distances&quot;) + theme(title = element_text(size = 12)) # makes titles smaller euclidean_patient_status_plot 8.2.2 PCoA with continuous sample grouping variable shown with colors We can also use continues values to group variables. Let’s use Shannon diversity index that we calculated in “Alpha diversity” notebook. # Adds coloring information to the data frame, creates new column euclidean_shannon_pcoa_df &lt;- cbind(euclidean_pcoa_df, shannon = colData(tse)$Shannon_index) # Creates a plot euclidean_shannon_plot &lt;- ggplot(data = euclidean_shannon_pcoa_df, aes(x=pcoa1, y=pcoa2, color = shannon)) + geom_point() + labs(x = &quot;Coordinate 1&quot;, y = &quot;Coordinate 2&quot;, title = &quot;PCoA with Aitchison distances&quot;) + theme(title = element_text(size = 12)) # makes titles smaller euclidean_shannon_plot 8.3 Estimating associations with an external variable Next we show how the quantify the strength of association between the variation in community composition (beta diversity) and external factors. The standard way to do this is to perform a so-called permutational multivariate analysis of variance (PERMANOVA) test. # Relative abundance table rel_abund_assay &lt;- assays(tse)$relabundance # Transposes it to get taxa to columns rel_abund_assay &lt;- t(rel_abund_assay) permanova_cohort &lt;- vegan::adonis(rel_abund_assay ~ cohort, data = colData(tse), permutations = 9999) # P-value print(paste0(&quot;Different different cohorts and variance of abundance between samples, p-value: &quot;, as.data.frame(permanova_cohort$aov.tab)[&quot;cohort&quot;, &quot;Pr(&gt;F)&quot;])) ## [1] &quot;Different different cohorts and variance of abundance between samples, p-value: 0.7384&quot; As we see, the cohort variable is not significantly associated with microbiota composition (p-value is over 0.05). We can, however, visualize those taxa whose abundance are the most different between cohorts. This gives us information which taxa’s abundances tend to differ between different cohorts. In order to do that, we need coefficients of taxa. # Gets the coefficients coef &lt;- coefficients(permanova_cohort)[&quot;cohort1&quot;,] # Gets the highest coefficients top.coef &lt;- sort(head(coef[rev(order(abs(coef)))],20)) # Plots the coefficients top_taxa_coeffient_plot &lt;- ggplot(data.frame(x = top.coef, y = factor(names(top.coef), unique(names(top.coef)))), aes(x = x, y = y)) + geom_bar(stat=&quot;identity&quot;) + labs(x=&quot;&quot;, y=&quot;&quot;, title=&quot;Top Taxa&quot;) + theme_bw() top_taxa_coeffient_plot The above plot shows taxa as code names, and it is hard to tell which bacterial groups they represent. However, it is easy to add human readable names. We can fetch those from rowData. Here we use Genus level names. # Gets corresponding Genus level names and stores them to top.coef names &lt;- rowData(tse)[names(top.coef), ][,&quot;Genus&quot;] # Adds new labels to the plot top_taxa_coeffient_plot &lt;- top_taxa_coeffient_plot + scale_y_discrete(labels = names) # Adds new labels top_taxa_coeffient_plot 8.4 Further resources For more examples, see a dedicated section on beta diversity in the online book. "],["dirichlet-multinomial-mixture-model.html", "9 Dirichlet-Multinomial Mixture Model 9.1 PCoA for ASV-level data with Bray-Curtis; with DMM clusters shown with colors", " 9 Dirichlet-Multinomial Mixture Model This section focus on DMM analysis. One technique that allows to search for groups of samples that are similar to each other is the Dirichlet-Multinomial Mixture Model. In DMM, we first determine the number of clusters (k) that best fit the data (model evidence) using Laplace approximation. After fitting the model with k clusters, we obtain for each sample k probabilities that reflect the probability that a sample belongs to the given cluster. Let’s cluster the data with DMM clustering. # Runs model and calculates the most likely number of clusters from 1 to 7. # For this small data, takes about 10 seconds. For larger data, can take much longer # because this demands lots of resources. tse_dmn &lt;- runDMN(tse, name = &quot;DMN&quot;, k = 1:7) # It is stored in metadata tse_dmn ## class: TreeSummarizedExperiment ## dim: 151 27 ## metadata(1): DMN ## assays(3): counts relabundance clr ## rownames(151): 1726470 1726471 ... 17264756 17264757 ## rowData names(6): Kingdom Phylum ... Family Genus ## colnames(27): A110 A12 ... A35 A38 ## colData names(6): patient_status cohort ... Shannon_index Faith_diversity_index ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## rowLinks: a LinkDataFrame (151 rows) ## rowTree: 1 phylo tree(s) (151 leaves) ## colLinks: NULL ## colTree: NULL Return information on metadata that the object contains. names(metadata(tse_dmn)) ## [1] &quot;DMN&quot; This returns a list of DMN objects for a closer investigation. getDMN(tse_dmn) ## [[1]] ## class: DMN ## k: 1 ## samples x taxa: 27 x 151 ## Laplace: 12049.73 BIC: 12271.38 AIC: 12173.55 ## ## [[2]] ## class: DMN ## k: 2 ## samples x taxa: 27 x 151 ## Laplace: 11704.82 BIC: 12399.15 AIC: 12202.83 ## ## [[3]] ## class: DMN ## k: 3 ## samples x taxa: 27 x 151 ## Laplace: 11059.76 BIC: 12266.31 AIC: 11971.51 ## ## [[4]] ## class: DMN ## k: 4 ## samples x taxa: 27 x 151 ## Laplace: 11417.51 BIC: 13047.39 AIC: 12654.11 ## ## [[5]] ## class: DMN ## k: 5 ## samples x taxa: 27 x 151 ## Laplace: 11217.24 BIC: 13305.58 AIC: 12813.8 ## ## [[6]] ## class: DMN ## k: 6 ## samples x taxa: 27 x 151 ## Laplace: 11202.18 BIC: 13718.9 AIC: 13128.65 ## ## [[7]] ## class: DMN ## k: 7 ## samples x taxa: 27 x 151 ## Laplace: 11684.01 BIC: 14400.77 AIC: 13712.03 Show Laplace approximation (model evidence) for each model of the k models. plotDMNFit(tse_dmn, type = &quot;laplace&quot;) Return the model that has the best fit. getBestDMNFit(tse_dmn, type = &quot;laplace&quot;) ## class: DMN ## k: 3 ## samples x taxa: 27 x 151 ## Laplace: 11059.76 BIC: 12266.31 AIC: 11971.51 9.1 PCoA for ASV-level data with Bray-Curtis; with DMM clusters shown with colors Group samples and return DMNGroup object that contains a summary. Patient status is used for grouping. dmn_group &lt;- calculateDMNgroup(tse_dmn, variable = &quot;patient_status&quot;, exprs_values = &quot;counts&quot;, k = 3) dmn_group ## class: DMNGroup ## summary: ## k samples taxa NLE LogDet Laplace BIC AIC ## ADHD 3 13 151 6018.131 -344.7893 5427.62 6601.657 6473.131 ## Control 3 14 151 6647.269 -147.5241 6155.39 7247.655 7102.269 Mixture weights (rough measure of the cluster size). DirichletMultinomial::mixturewt(getBestDMNFit(tse_dmn)) ## pi theta ## 1 0.4814815 31.27764 ## 2 0.2962963 47.34431 ## 3 0.2222222 92.27394 Samples-cluster assignment probabilities / how probable it is that sample belongs to each cluster head(DirichletMultinomial::mixture(getBestDMNFit(tse_dmn))) ## [,1] [,2] [,3] ## A110 1.000000e+00 1.245878e-144 7.614906e-205 ## A12 9.815777e-117 6.112824e-93 1.000000e+00 ## A15 1.000000e+00 9.468644e-119 3.414255e-234 ## A19 5.373244e-112 1.814912e-107 1.000000e+00 ## A21 2.145215e-93 4.715927e-96 1.000000e+00 ## A23 1.000000e+00 8.790751e-111 1.948491e-161 Contribution of each taxa to each component head(DirichletMultinomial::fitted(getBestDMNFit(tse_dmn))) ## [,1] [,2] [,3] ## 1726470 6.352199035 2.898736178 20.1892586 ## 1726471 5.287913008 0.002047309 0.1532229 ## 17264731 0.001248794 9.144551105 2.0112022 ## 17264726 0.140478993 1.363534648 7.5893565 ## 1726472 2.104142707 3.523458766 2.6656992 ## 17264724 0.072367856 0.002047309 9.8545567 Get the assignment probabilities prob &lt;- DirichletMultinomial::mixture(getBestDMNFit(tse_dmn)) # Add column names colnames(prob) &lt;- c(&quot;comp1&quot;, &quot;comp2&quot;, &quot;comp3&quot;) # For each row, finds column that has the highest value. Then extract the column # names of highest values. vec &lt;- colnames(prob)[max.col(prob,ties.method = &quot;first&quot;)] # Creates a data frame that contains principal coordinates and DMM information euclidean_dmm_pcoa_df &lt;- cbind(euclidean_pcoa_df, dmm_component = vec) # Creates a plot euclidean_dmm_plot &lt;- ggplot(data = euclidean_dmm_pcoa_df, aes(x=pcoa1, y=pcoa2, color = dmm_component)) + geom_point() + labs(x = &quot;Coordinate 1&quot;, y = &quot;Coordinate 2&quot;, title = &quot;PCoA with Aitchison distances&quot;) + theme(title = element_text(size = 12)) # makes titles smaller euclidean_dmm_plot "],["differential-abundance-analysis.html", "10 Differential abundance analysis 10.1 Wilcoxon test 10.2 DESeq2 10.3 ANCOM-BC 10.4 Comparison of Wilcoxon test and DESeq2 10.5 Comparison of abundance", " 10 Differential abundance analysis Here, we analyse abundances with three different methods: Wilcoxon test, DESeq2, and ANCOM-BC. All of these test statistical differences between groups. We analyse Genus level abundances. 10.1 Wilcoxon test A Wilcoxon test estimates difference between two groups. It is a non-parametric alternative to a t-test, which means that the Wilcoxon test does not require normally distributed data. Let’s first collect the data for the testing purpose. # Agglomerates data to Genus level tse_genus &lt;- agglomerateByRank(tse, rank = &quot;Genus&quot;) # Does clr transformation. Pseudocount is added, because data contains zeros, and # clr transformation includes log transformation. tse_genus &lt;- transformCounts(tse_genus, method = &quot;clr&quot;, pseudocount = 1) # Does transpose, so samples are in rows, then creates a data frame. abundance_analysis_data &lt;- data.frame(t(assay(tse_genus, &quot;clr&quot;))) # Then we need variable for grouping samples. &quot;patient_status&quot; column includes information # about patients&#39; status. There two groups &quot;ADHD&quot; and &quot;control&quot;. Let&#39;s include that to the data frame. abundance_analysis_data &lt;- cbind(abundance_analysis_data, patient_status = colData(tse_genus)$patient_status) Now we can do the Wilcoxon test. We test all the taxa by looping through columns, and store individual p-values to a vector. Then we create a data frame from collected data. Code below does the Wilcoxon test only for columns that contain abundances, not for column that contain patient status. colnames &lt;- names(abundance_analysis_data[, !names(abundance_analysis_data) %in% &quot;patient_status&quot;]) wilcoxon_p &lt;- c() # Initialize empty vector for p-values # Do for loop over selected column names for (i in colnames) { result &lt;- wilcox.test(abundance_analysis_data[, i] ~ patient_status, data = abundance_analysis_data) # Stores p-value to the vector with this column name wilcoxon_p[[i]] &lt;- result$p.value } wilcoxon_p &lt;- data.frame(taxa = names(wilcoxon_p), p_raw = unlist(wilcoxon_p)) Multiple tests were performed. These are not independent, so we need to adjust p-values for multiple testing. Otherwise, we would increase the chance of a type I error drastically depending on our p-value threshold. By applying a p-value adjustment, we can keep the false positive rate at a level that is acceptable. What is acceptable depends on our research goals. Here we use the fdr method, but there are several other methods as well. wilcoxon_p$p_adjusted &lt;- p.adjust(wilcoxon_p$p_raw, method = &quot;fdr&quot;) df &lt;- data.frame(x = c(wilcoxon_p$p_raw, wilcoxon_p$p_adjusted), type=rep(c(&quot;raw&quot;, &quot;holm&quot;), c(length(wilcoxon_p$p_raw), length(wilcoxon_p$p_adjusted)))) wilcoxon_plot &lt;- ggplot(df) + geom_histogram(aes(x=x, fill=type)) + labs(x = &quot;p-value&quot;, y = &quot;Frequency&quot;) wilcoxon_plot ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. 10.2 DESeq2 Our second analysis method is DESeq2. This performs the data normalization automatically. It also takes care of the p-value adjustment, so we don’t have to worry about that. DESeq2 uses negative binomial distribution to detect differences in read counts between groups. Its normalization takes care of the differences between library sizes and compositions. DESeq2 analysis includes multiple steps, but they are done automatically. More information can be found, e.g., from Harvard Chan Bioinformatic Core’s tutorial Introduction to DGE - ARCHIVED Now let us show how to do this. First, run the DESeq2 analysis. # Creates DESeq2 object from the data. Uses &quot;patient_status&quot; to create groups. ds2 &lt;- DESeqDataSet(tse_genus, ~patient_status) ## converting counts to integer mode ## Warning in DESeqDataSet(tse_genus, ~patient_status): 2 duplicate rownames were renamed by adding numbers ## Warning in DESeqDataSet(tse_genus, ~patient_status): some variables in design formula are characters, converting to factors # Does the analysis dds &lt;- DESeq(ds2) ## estimating size factors ## estimating dispersions ## gene-wise dispersion estimates ## mean-dispersion relationship ## final dispersion estimates ## fitting model and testing ## -- replacing outliers and refitting for 11 genes ## -- DESeq argument &#39;minReplicatesForReplace&#39; = 7 ## -- original counts are preserved in counts(dds) ## estimating dispersions ## fitting model and testing # Gets the results from the object res &lt;- results(dds) # Creates a data frame from results df &lt;- as.data.frame(res) # Adds taxon column that includes names of taxa df$taxon &lt;- rownames(df) # Orders the rows of data frame in increasing order firstly based on column &quot;log2FoldChange&quot; # and secondly based on &quot;padj&quot; column df &lt;- df %&gt;% arrange(log2FoldChange, padj) knitr::kable(head(df)) baseMean log2FoldChange lfcSE stat pvalue padj taxon Genus:Ruminococcaceae_UCG-014 22.548297 -24.891268 2.460684 -10.115589 0.0000000 0.0000000 Genus:Ruminococcaceae_UCG-014 Order:Bacteroidales 40.353733 -9.241798 2.136205 -4.326270 0.0000152 0.0002730 Order:Bacteroidales Genus:Faecalibacterium 231.079502 -7.074433 1.745612 -4.052694 0.0000506 0.0006835 Genus:Faecalibacterium Genus:Catabacter 18.045614 -6.615454 1.716150 -3.854823 0.0001158 0.0012508 Genus:Catabacter Genus:Butyricicoccus 2.392885 -5.179608 2.948055 -1.756957 0.0789251 0.3278426 Genus:Butyricicoccus Order:Gastranaerophilales 2.067972 -3.054975 2.938641 -1.039588 0.2985315 0.7269742 Order:Gastranaerophilales 10.3 ANCOM-BC The analysis of composition of microbiomes with bias correction (ANCOM-BC) is a recently developed method for differential abundance testing. It is based on an earlier published approach. This method could be recommended as part of several approaches: A recent study compared several mainstream methods and found that among another method, ANCOM-BC produced the most consistent results and is probably a conservative approach. Please note that based on this and other comparisons, no single method can be recommended across all datasets. Rather, it could be recommended to apply several methods and look at the overlap/differences. As the only method, ANCOM-BC incorporates the so called sampling fraction into the model. The latter term could be empirically estimated by the ratio of the library size to the microbial load. Variations in this sampling fraction would bias differential abundance analyses if ignored. Furthermore, this method provides p-values, and confidence intervals for each taxon. It also controls the FDR and it is computationally simple to implement. As we will see below, to obtain results, all that is needed is to pass a phyloseq object to the ancombc() function. Therefore, below we first convert our tse object to a phyloseq object. Then, we specify the formula. In this formula, other covariates could potentially be included to adjust for confounding. Please check the function documentation to learn about the additional arguments that we specify below. # currently, ancombc requires the phyloseq format, but we can easily convert: pseq &lt;- makePhyloseqFromTreeSummarizedExperiment(tse) pseq_genus &lt;- phyloseq::tax_glom(pseq, taxrank = &quot;Genus&quot;) out = ancombc( phyloseq = pseq_genus, formula = &quot;patient_status&quot;, p_adj_method = &quot;holm&quot;, zero_cut = 0.90, lib_cut = 0, group = &quot;patient_status&quot;, struc_zero = TRUE, neg_lb = TRUE, tol = 1e-5, max_iter = 100, conserve = TRUE, alpha = 0.05, global = TRUE ) res &lt;- out$res The object out contains all relevant information. Again, see the documentation of the function under Value for an explanation of all the output objects. Our question can be answered by looking at the res object, which now contains dataframes with the coefficients, standard errors, p-values and q-values. Conveniently, there is a dataframe diff_abn. Here, we can find all differentiallt abundant taxa. Below we show the first 6 entries of this dataframe: knitr::kable(head(res$diff_abn)) patient_statusControl 172647198 FALSE 1726478 FALSE 172647201 FALSE 17264798 FALSE 172647195 FALSE 1726472 FALSE In total, this method detects 13 differentially abundant taxa. 10.4 Comparison of Wilcoxon test and DESeq2 Let’s compare results that we got from the Wilcoxon test and DESeq2. As we can see from the scatter plot, DESeq2 gives lower p-values than Wilcoxon test. mf &lt;- data.frame(df$padj, wilcoxon_p$p_adjusted) p &lt;- ggplot(mf, aes(x = df$padj, y = wilcoxon_p$p_adjusted)) + labs(x = &quot;DESeq2 adjusted p-value&quot;, y = &quot;Wilcoxon test adjusted p-value&quot;) + geom_count() + scale_size_area(max_size = 10) print(p) Prints number of p-values under 0.05 print(paste0(&quot;DESeq2 p-values under 0.05: &quot;, sum(df$padj&lt;0.05, na.rm = TRUE), &quot;/&quot;, length(df$padj))) ## [1] &quot;DESeq2 p-values under 0.05: 7/54&quot; print(paste0(&quot;Wilcoxon test p-values under 0.05: &quot;, sum(wilcoxon_p$p_adjusted&lt;0.05, na.rm = TRUE), &quot;/&quot;, length(wilcoxon_p$p_adjusted))) ## [1] &quot;Wilcoxon test p-values under 0.05: 2/54&quot; 10.5 Comparison of abundance In previous steps, we got information which taxa vary between ADHD and control groups. Let’s plot those taxa in the boxplot, and compare visually if abundances of those taxa differ in ADHD and control samples. For comparison, let’s plot also taxa that do not differ between ADHD and control groups. Let’s first gather data about taxa that have highest p-values. # There are some taxa that do not include Genus level information. They are # excluded from analysis. # str_detect finds if the pattern is present in values of &quot;taxon&quot; column. # Subset is taken, only those rows are included that do not include the pattern. df &lt;- df[ !stringr::str_detect(df$taxon, &quot;Genus:uncultured&quot;), ] # Sorts p-values in decreasing order. Takes 3rd first ones. Takes those rows that match # with p-values. Takes taxa. highest3 &lt;- df[df$padj %in% sort(df$padj, decreasing = TRUE)[1:3], ]$taxon # From clr transformed table, takes only those taxa that had highest p-values highest3 &lt;- assay(tse_genus, &quot;clr&quot;)[highest3, ] # Transposes the table highest3 &lt;- t(highest3) # Adds colData that includes patient status infomation highest3 &lt;- data.frame(highest3, as.data.frame(colData(tse_genus))) # Some taxa names are that long that they don&#39;t fit nicely into title. So let&#39;s add there # a line break after e.g. &quot;Genus&quot;. Here the dot after e.g. Genus is replaced with # &quot;: \\n&quot; colnames(highest3)[1:3] &lt;- lapply(colnames(highest3)[1:3], function(x){ # Replaces the first dot temp &lt;- stringr::str_replace(x, &quot;[.]&quot;, &quot;: &quot;) # Replace all other dots and underscores with space temp &lt;- stringr::str_replace_all(temp, c(&quot;[.]&quot; = &quot; &quot;, &quot;_&quot; = &quot; &quot;)) # Adds line break so that 25 characters is the maximal width temp &lt;- stringr::str_wrap(temp, width = 25) }) Next, let’s do the same but for taxa with lowest p-values. # Sorts p-values in increasing order. Takes 3rd first ones. Takes those rows that match # with p-values. Takes taxa. lowest3 &lt;- df[df$padj %in% sort(df$padj, decreasing = FALSE)[1:3], ]$taxon # From clr transformed table, takes only those taxa that had lowest p-values lowest3 &lt;-assay(tse_genus, &quot;clr&quot;)[lowest3, ] # Transposes the table lowest3 &lt;- t(lowest3) # Adds colData that includes patient status infomation lowest3 &lt;- data.frame(lowest3, as.data.frame(colData(tse_genus))) # Some taxa names are that long that they don&#39;t fit nicely into title. So let&#39;s add there # a line break after e.g. &quot;Genus&quot;. Here the dot after e.g. Genus is replaced with # &quot;: \\n&quot; colnames(lowest3)[1:3] &lt;- lapply(colnames(lowest3)[1:3], function(x){ # Replaces the first dot temp &lt;- stringr::str_replace(x, &quot;[.]&quot;, &quot;: &quot;) # Replace all other dots and underscores with space temp &lt;- stringr::str_replace_all(temp, c(&quot;[.]&quot; = &quot; &quot;, &quot;_&quot; = &quot; &quot;)) # Adds line break so that 25 characters is the maximal width temp &lt;- stringr::str_wrap(temp, width = 25) }) Then we can plot these six different taxa. Let’s arrange them into the same picture. # Puts plots in the same picture gridExtra::grid.arrange( # Plot 1 ggplot(highest3, aes(x = patient_status, y = highest3[,1])) + geom_boxplot() + ylab(&quot;CLR abundances&quot;) + # y axis title ggtitle(names(highest3)[1]) + # main title theme(title = element_text(size = 7), axis.text = element_text(size = 7), axis.title.x=element_blank()), # makes titles smaller, removes x axis title # Plot 2 ggplot(highest3, aes(x = patient_status, y = highest3[,2])) + geom_boxplot() + ylab(&quot;CLR abundances&quot;) + # y axis title ggtitle(names(highest3)[2]) + # main title theme(title = element_text(size = 7), axis.text = element_text(size = 7), axis.title.x=element_blank()), # makes titles smaller, removes x axis title # Plot 3 ggplot(highest3, aes(x = patient_status, y = highest3[,3])) + geom_boxplot() + ylab(&quot;CLR abundances&quot;) + # y axis title ggtitle(names(highest3)[3]) + # main title theme(title = element_text(size = 7), axis.text = element_text(size = 7), axis.title.x=element_blank()), # makes titles smaller, removes x axis title # Plot 4 ggplot(lowest3, aes(x = patient_status, y = lowest3[,1])) + geom_boxplot() + ylab(&quot;CLR abundances&quot;) + # y axis title ggtitle(names(lowest3)[1]) + # main title theme(title = element_text(size = 7), axis.text = element_text(size = 7), axis.title.x=element_blank()), # makes titles smaller, removes x axis title # Plot 5 ggplot(lowest3, aes(x = patient_status, y = lowest3[,2])) + geom_boxplot() + ylab(&quot;CLR abundances&quot;) + # y axis title ggtitle(names(lowest3)[2]) + # main title theme(title = element_text(size = 7), axis.text = element_text(size = 7), axis.title.x=element_blank()), # makes titles smaller, removes x axis title # Plot 6 ggplot(lowest3, aes(x = patient_status, y = lowest3[,3])) + geom_boxplot() + ylab(&quot;CLR abundances&quot;) + # y axis title ggtitle(names(lowest3)[3]) + # main title theme(title = element_text(size = 7), axis.text = element_text(size = 7), axis.title.x=element_blank()), # makes titles smaller, removes x axis title # 3 columns and 2 rows ncol = 3, nrow = 2 ) "],["study-material.html", "11 Study material 11.1 Lecture slides 11.2 Example solutions 11.3 R programming resources 11.4 Resources for TreeSummarizedExperiment 11.5 Resources for phyloseq 11.6 Further reading", " 11 Study material 11.1 Lecture slides To be added. 11.2 Example solutions To be added. 11.3 R programming resources R programming basics: Base R Basics of R programming: Base R R cheat sheets R visualization with ggplot2 R graphics cookbook Rmarkdown Rmarkdown tips RStudio RStudio cheat sheet 11.4 Resources for TreeSummarizedExperiment SingleCellExperiment Publication Project page SummarizedExperiment Publication Project page TreeSummarizedExperiment Publication Project page 11.5 Resources for phyloseq List of R tools for microbiome analysis phyloseq microbiome tutorial microbiomeutilities 11.6 Further reading Data Analysis and Visualization in R for Ecologists by Data Carpentry Modern Statistics for Modern Biology. Holmes &amp; Huber (2018) for background in statistical analysis Microbiome Data Science. Shetty &amp; Lahti, 2019 "],["miscellaneous-material.html", "12 Miscellaneous material 12.1 Shapiro-Wilk test 12.2 Deseq details", " 12 Miscellaneous material 12.1 Shapiro-Wilk test If necessary, it is possible to assess normality of the data with Shapiro-Wilk test. # Does Shapiro-Wilk test. Does it only for columns that contain abundances, not for # column that contain Groups. normality_test_p &lt;- c() for (column in abundance_analysis_data[, !names(abundance_analysis_data) %in% &quot;patient_status&quot;]){ # Does Shapiro-Wilk test result &lt;- shapiro.test(column) # Stores p-value to vector normality_test_p &lt;- c(normality_test_p, result$p.value) } print(paste0(&quot;P-values over 0.05: &quot;, sum(normality_test_p&gt;0.05), &quot;/&quot;, length(normality_test_p))) ## [1] &quot;P-values over 0.05: 7/54&quot; 12.2 Deseq details Raw counts are normalized by log-based scaling. Taxa-wise variance is estimated. These values tell how much each taxa varies between samples. A curve is fitted over all those taxa-wise variance estimates that we got in the last step. This model tells how big the variance is in a specific abundance level. The model is used to shrink those individual variance estimates to avoid the effect of, e.g., small sample size and higher variance. This reduces the likelihood to get false positives. Variance estimates are used to compare different groups. We receive a result that shows whether the variance is explained by groups. "]]
